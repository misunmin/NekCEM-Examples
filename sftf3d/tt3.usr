c-----------------------------------------------------------------------
c
c     Superimposed normally-incident plane waves striking a flat sheet
c     of graphene.
c
c-----------------------------------------------------------------------
      function incident(tt,xx,yy,zz)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'PML'

      common /userparam/ omega,kn,eps,mu,c,direction(3),polarization(3)
      real omega,kn,eps,mu,c,direction,polarization

      logical incident
      real tt,xx,yy,zz

      real x0,y0,z0,t_arrive

      x0 = pmlinner(1)
      y0 = pmlinner(4)
      z0 = pmlinner(6)

c     Project the point onto the line made by the wavefront and divide
c     by the speed to get how long it will take for the wave to arrive
      t_arrive = (direction(1)*(xx-x0)
     $          + direction(2)*(yy-y0) 
     $          + direction(3)*(zz-z0))/c


      if (tt.ge.t_arrive) then
         incident = .true.
      else
         incident = .false.
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userinc(tt,incfhx,incfhy,incfhz,incfex,incfey,incfez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'RK5'
      include 'PML'

      common /userparam/ omega,kn,eps,mu,c,direction(3),polarization(3)
      real omega,kn,eps,mu,c,direction,polarization

      common /userincvars/ incindex,ninc
      integer incindex(lxzfl),ninc

      real incfhx(lxzfl),incfhy(lxzfl),incfhz(lxzfl)
      real incfex(lxzfl),incfey(lxzfl),incfez(lxzfl)

      integer i,j,k
      real tt,xx,yy,zz,x0,y0,z0
      logical incident
      real eta,uinc
      real tmp(3)

      x0 = pmlinner(1)
      y0 = pmlinner(4)
      z0 = pmlinner(6)

      do i = 1,ninc
         j = incindex(i)
         k = cemface(j)

         xx = xm1(k,1,1,1)
         yy = ym1(k,1,1,1)
         zz = zm1(k,1,1,1)

         eta = sqrt(mu/eps)

         if (incident(tt,xx,yy,zz)) then
               uinc = sin(kn*(direction(1)*(xx-x0)
     $                      + direction(2)*(yy-y0)
     $                      + direction(3)*(zz-z0))-omega*tt)

               incfhx(j) = incfhx(j) + uinc * polarization(1)
               incfhy(j) = incfhy(j) + uinc * polarization(2)
               incfhz(j) = incfhz(j) + uinc * polarization(3)

               tmp(1)= direction(2)*polarization(3)
     $               - direction(3)*polarization(2)
               tmp(2)= direction(3)*polarization(1)
     $               - direction(1)*polarization(3)
               tmp(3)= direction(1)*polarization(2)
     $               - direction(2)*polarization(1)

               incfex(j) = incfex(j) - eta*uinc*tmp(1) 
               incfey(j) = incfey(j) - eta*uinc*tmp(2)
               incfez(j) = incfez(j) - eta*uinc*tmp(3) 
          endif

      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine userini(tt,hx,hy,hz,ex,ey,ez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      real tt
      real hx(lpts),hy(lpts),hz(lpts)
      real ex(lpts),ey(lpts),ez(lpts)

      return
      end
c-----------------------------------------------------------------------
      subroutine usersol(tt,solhx,solhy,solhz,solex,soley,solez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      real tt
      real solhx(lpts),solhy(lpts),solhz(lpts)
      real solex(lpts),soley(lpts),solez(lpts)

      return
      end
c-----------------------------------------------------------------------
      subroutine usersrc(tt,srchx,srchy,srchz,srcex,srcey,srcez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      real tt
      real srchx(lpts),srchy(lpts),srchz(lpts)
      real srcex(lpts),srcey(lpts),srcez(lpts)

      return
      end
c-----------------------------------------------------------------------
      subroutine userfsrc(tt,srcfhx,srcfhy,srcfhz,srcfex,srcfey,srcfez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'EMWAVE'

      common /usergraph/ fjn(lxzfl,3,6),kfjn(lxzfl,3,6),resfjn(lxzfl,3
     $     ,6),graphparams(lxzfl,12),graphindex(lxzfl),ngraph
      real fjn,kfjn,resfjn,graphparams
      integer graphindex,ngraph

      real tt
      real srcfhx(lxzfl),srcfhy(lxzfl),srcfhz(lxzfl)
      real srcfex(lxzfl),srcfey(lxzfl),srcfez(lxzfl)

      integer i,j

      call cem_3d_graphene_current(fjn,kfjn,resfjn,graphparams
     $     ,graphindex,ngraph)

      do i = 1,ngraph
         j = graphindex(i)
         srcfhx(j) = srcfhx(j)-fjn(j,1,1)
         srcfhy(j) = srcfhy(j)-fjn(j,2,1)
         srcfhz(j) = srcfhz(j)-fjn(j,3,1)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine uservp(ix,iy,iz,iel)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'PML'    

      common /userparam/ omega,kn,eps,mu,c,direction(3),polarization(3)
      real omega,kn,eps,mu,c,direction,polarization

      logical incident
      real tt,xx,yy,zz,tol

      common /usergraph/ fjn(lxzfl,3,6),kfjn(lxzfl,3,6)
     $     ,resfjn(lxzfl,3,6),graphparams(lxzfl,12),graphindex(lxzfl)
     $     ,ngraph
      real fjn,kfjn,resfjn,graphparams
      integer graphindex,ngraph

      common /userincvars/ incindex,ninc
      integer incindex(lxzfl),ninc

      integer ix,iy,iz,iel

      logical on_pmlinner,markinc,mark2d
      integer e,f,i,j,k,nx1_2
      real tmp

      real a_d,b_d,b_cp1,a_211,a_221,
     $     b_11,b_21,b_cp2,a_212,a_222,b_12,b_22

      omega = 5.0
      eps = 1.0
      mu = 1.0

      direction(1) = 1.0
      direction(2) = 1.0
      direction(3) = -1.0

      tmp = direction(1)**2+direction(2)**2+direction(3)**2 
      tmp = sqrt(tmp)

      direction(1) = direction(1)/tmp
      direction(2) = direction(2)/tmp
      direction(3) = direction(3)/tmp

      polarization(1)= 1.0/2.0
      polarization(2)= 1.0/2.0
      polarization(3)= 1.0/2.0

      c = 1.0/sqrt(mu*eps)
      kn = omega*sqrt(mu*eps)

c     Set the parameters for the graphene
      a_d = 0.000e+00
      b_d = 1.499e+00
      b_cp1 = -2.599e-03
      a_211 = 4.632e+05
      a_221 = 1.090e+03
      b_11 = -1.391e+00
      b_21 = -3.125e+02
      b_cp2 = -1.049e-03
      a_212 = 4.271e+05
      a_222 = 2.742e+02
      b_12 = -7.769e-02
      b_22 = 4.268e+02

      nx1_2 = nx1/2
c     Set the permittivity and permeability
      do e = 1,nelt
         do i = 1,nxyz
            j = i+nx1*ny1*nz1*(e-1)
	    permittivity(j) = eps
            permeability(j) = mu
         enddo
      enddo

c     Build an index of where the incident field needs to be added
      ninc = 0
      ngraph = 0
      tol = 1e-8

      do e = 1,nelt
         if (pmltag(e).eq.0) then
            cycle
         endif

         do f = 1,nfaces
            markinc = .true.
            do i = 1,nxzf
               j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
               k = cemface(j)

               xx = xm1(k,1,1,1)
               yy = ym1(k,1,1,1)
               zz = zm1(k,1,1,1)

               if (.not.on_pmlinner(xx,yy,zz)) then
                  markinc = .false.
                  exit
               endif
            enddo
            if (markinc) then
               do i = 1,nxzf
                  j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
                  ninc = ninc+1
                  incindex(ninc) = j
               enddo
            endif
         enddo
      enddo


c     Build an index of where there's graphene
      do e = 1,nelt
         do f = 1,nfaces
            mark2d = .true.
            do i = 1,nxzf
               j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
               k = cemface(j)
               if ((abs(zm1(k,1,1,1)).gt.tol).or.
     $             (abs(xm1(k,1,1,1)).gt.1+tol).or.  
     $             (abs(ym1(k,1,1,1)).gt.1+tol)) then
                  mark2d = .false.
                  exit
               endif
            enddo
            if (mark2d) then
               do i = 1,nxzf
                  ngraph = ngraph+1
                  j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
                  graphindex(ngraph) = j
                  graphparams(j,1) = a_d
                  graphparams(j,2) = b_d
                  graphparams(j,3) = b_cp1
                  graphparams(j,4) = a_211
                  graphparams(j,5) = a_221
                  graphparams(j,6) = b_11
                  graphparams(j,7) = b_21
                  graphparams(j,8) = b_cp2
                  graphparams(j,9) = a_212
                  graphparams(j,10) = a_222
                  graphparams(j,11) = b_12
                  graphparams(j,12) = b_22
               enddo
            endif
         enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      function on_pmlinner(xx,yy,zz)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'PML'

      logical on_pmlinner
      real xx,yy,zz

      real tol

      tol = 1e-14


   
      if     (abs(xx-pmlinner(1)).lt.tol
     $       .and.yy.gt.pmlinner(3)-tol
     $       .and.yy.lt.pmlinner(4)+tol
     $       .and.zz.gt.pmlinner(5)-tol
     $       .and.zz.lt.pmlinner(6)+tol) then

         on_pmlinner = .true.

      elseif (abs(xx-pmlinner(2)).lt.tol
     $        .and.yy.gt.pmlinner(3)-tol
     $        .and.yy.lt.pmlinner(4)+tol       
     $        .and.zz.gt.pmlinner(5)-tol
     $        .and.zz.lt.pmlinner(6)+tol) then
         on_pmlinner = .true.

      elseif (abs(yy-pmlinner(3)).lt.tol
     $        .and.xx.gt.pmlinner(1)-tol
     $        .and.xx.lt.pmlinner(2)+tol         
     $        .and.zz.gt.pmlinner(5)-tol
     $        .and.zz.lt.pmlinner(6)+tol) then
         on_pmlinner = .true.

      elseif (abs(yy-pmlinner(4)).lt.tol
     $        .and.xx.gt.pmlinner(1)-tol
     $        .and.xx.lt.pmlinner(2)+tol       
     $        .and.zz.gt.pmlinner(5)-tol
     $        .and.zz.lt.pmlinner(6)+tol) then
         on_pmlinner = .true.

      elseif (abs(zz-pmlinner(5)).lt.tol
     $        .and.xx.gt.pmlinner(1)-tol
     $        .and.xx.lt.pmlinner(2)+tol       
     $        .and.yy.gt.pmlinner(3)-tol
     $        .and.yy.lt.pmlinner(4)+tol) then
         on_pmlinner = .true.

      elseif (abs(zz-pmlinner(6)).lt.tol
     $        .and.xx.gt.pmlinner(1)-tol
     $        .and.xx.lt.pmlinner(2)+tol       
     $        .and.yy.gt.pmlinner(3)-tol
     $        .and.yy.lt.pmlinner(4)+tol) then
         on_pmlinner = .true.

      else
         on_pmlinner = .false.

      endif


      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
c-----------------------------------------------------------------------
      implicit none

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
c-----------------------------------------------------------------------
c     Use this subroutine to set the dimensions of the domain.
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      integer e,f,i,j,n,nxy2
      real glmin,glmax
      real sx,sy,sz,xmid,ymid,zmid
      real xmin,ymin,zmin,xmax,ymax,zmax

      n = nx1*ny1*nz1*nelv

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)
      zmin = glmin(zm1,n)
      zmax = glmax(zm1,n)

      sx = 5.0
      sy = 5.0
      sz = 5.0

      do i = 1,n
         xm1(i,1,1,1) = sx*(xm1(i,1,1,1)-xmin)/(xmax-xmin)-(sx/2.0)
         ym1(i,1,1,1) = sy*(ym1(i,1,1,1)-ymin)/(ymax-ymin)-(sy/2.0)
         zm1(i,1,1,1) = sz*(zm1(i,1,1,1)-zmin)/(zmax-zmin)-(sz/2.0)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      common /ccpu/  cpu_t,cpu_dtime,cpu_chk
      real cpu_t,cpu_dtime,cpu_chk

      integer i
      real l2(6),linf(6)
      real l2tol(6),linftol(6)
      real cpu_p_t

      l2tol(1) = 5e-4
      l2tol(2) = 1e-14
      l2tol(3) = 5e-4
      l2tol(4) = 5e-4
      l2tol(5) = 1e-14
      l2tol(6) = 5e-4

      linftol(1) = 5e-3
      linftol(2) = 5e-12
      linftol(3) = 5e-3
      linftol(4) = 5e-3
      linftol(5) = 5e-12
      linftol(6) = 5e-3

      if (istep.le.10.or.mod(istep,iocomm).eq.0) then
         call usersol
     $     (time,shn(1,1),shn(1,2),shn(1,3),sen(1,1),sen(1,2),sen(1,3))

         call cem_error(hn(1,1),shn(1,1),errhn(1,1),npts,l2(1),linf(1))
         call cem_error(hn(1,2),shn(1,2),errhn(1,2),npts,l2(2),linf(2))
         call cem_error(hn(1,3),shn(1,3),errhn(1,3),npts,l2(3),linf(3))
         call cem_error(en(1,1),sen(1,1),erren(1,1),npts,l2(4),linf(4))
         call cem_error(en(1,2),sen(1,2),erren(1,2),npts,l2(5),linf(5))
         call cem_error(en(1,3),sen(1,3),erren(1,3),npts,l2(6),linf(6))

         call userprint(istep,time,dt,l2,linf,cpu_t,cpu_p_t)

c        do i = 1,6
c           if (l2(i).gt.l2tol(i)) call exitt(1)
c           if (linf(i).gt.linftol(i)) call exitt(1)
c        enddo
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userprint(istep,tt,dt,l2,linf,t1,t2)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      integer istep
      real tt,dt,t1,t2
      real l2(6),linf(6)

      integer k

      if (nid.eq.0) then
         write(6,101) istep,nelt,nx1-1,npts,tt,dt,(l2(k),k=1,6),t1,t2
         write(6,102) istep,nelt,nx1-1,npts,tt,dt,(linf(k),k=1,6),t1,t2
      endif

 101  format(/,i10,i6,i4,i9,1p9e10.3,e9.2,' CPU: L2')
 102  format(  i10,i6,i4,i9,1p9e10.3,e9.2,' CPU: Linf')

      return
      end
c-----------------------------------------------------------------------
